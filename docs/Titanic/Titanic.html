<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Mining</title>
    <meta charset="utf-8" />
    <meta name="author" content="Aldo Solari" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Data Mining
## I dati Titanic
### Aldo Solari

---






# Il contesto della classificazione

Siano  `\((X,Y) \in \mathcal{X} \times \mathcal{Y}\)` variabili casuali con distribuzione congiunta (ignota), dove
* `\(Y \in \{0,1\}\)` è una variabile risposta binaria
* `\(X=(X_1,\ldots,X_p)^\mathsf{T}\)` sono `\(p\)` predittori

Un classificatore è una funzione
`\(\hat{h}: \mathcal{X} \mapsto \{0,1\}\)`.
L'errore di classificazione di `\(\hat{h}\)` è definito da
`$$\mathrm{Err}(\hat{h}) = \mathbb{P}(Y \neq \hat{h}(X))$$`
E' possibile mostrare che l'errore di classificazione è minimizzato dal classificatore di Bayes
`$$h_{\mathrm{Bayes}}(x) = \left\{\begin{array}{ll}
1 &amp; \mathrm{se\,\,} \mathbb{P}(Y=1|X=x) &gt;1/2 \\
0 &amp; \mathrm{altrimenti}\\
\end{array}\right.$$`


---

# Errore stocastico e di approssimazione

Sia `$$h^* = \arg\min_{h \in \mathcal{H}} \mathrm{Err}(h)$$`
dove `\(\mathcal{H}\)` è la classe di classificatori considerata. L'errore di previsione si può scomporre in **errore stocastico** `\(\hat{h} - h^*\)` ed **errore di approssimazione** `\(h^* - h_{\mathrm{Bayes}}\)`

![](errors.png)


---

# Errore di training e di test

* Training set: `\((x_1, y_1), (x_2,y_2),\ldots, (x_n,y_n)\)`
* Test set: `\((x^*_1, y^*_1), (x^*_2,y^*_2),\ldots, (x^*_m,y^*_m)\)`


* __Errore di classificazione (training set)__

`$$\mathrm{Err}_{\mathrm{Tr}} = \frac{1}{n} \sum_{i=1}^{n} \mathbb{I}\{y_i \neq \hat{h}(x_i) \}$$`

* __Errore di classificazione (test set)__
`$$\mathrm{Err}_{\mathrm{Te}} = \frac{1}{m} \sum_{i=1}^{m} \mathbb{I}\{y^*_i \neq \hat{h}(x^*_i) \}$$`

* __Accuratezza (test set)__
`$$\mathrm{Acc}_{\mathrm{Te}} = 1- \mathrm{Err}_{\mathrm{Te}}$$`

---

layout: false
class: inverse, middle, center

# I dati Titanic


---

# Il disastro

Il 15 aprile 1912, durante il suo viaggio inaugurale, il Titanic affondò dopo essersi scontrato con un iceberg, causando la morte di 1502 persone (su 2224 tra passeggeri ed equipaggio)

![](https://vignette.wikia.nocookie.net/foreverknight/images/7/7f/Route_of_Titanic.svg/revision/latest/scale-to-width-down/640?cb=20090303115410)

* Training set di `\(n = 891\)` passeggeri, sui quali sono state misurate `\(10\)` variabili (predittori)

* L'obiettivo è prevedere la sorte (1 = sopravissuto, 0 = deceduto) di `\(m = 418\)` passeggeri del test set


---

# Letture consigliate

Si consiglia la lettura di [Varian (2014) Big Data: New Tricks for Econometrics](https://www.aeaweb.org/articles?id=10.1257/jep.28.2.3). In particolare

* l'esempio Titanic (sezione *Classification and Regression Trees*)

* il codice R utilizzato (potete scaricare il [data set](https://www.aeaweb.org/jep/data/2802/2802-0003_data.zip) nella sezione *Additional Materials*)

La competizione Kaggle 
[Titanic: Machine Learning from Disaster](https://www.kaggle.com/c/titanic). In particolare

* [Exploring Survival on the Titanic](https://www.kaggle.com/mrisdal/exploring-survival-on-the-titanic) è un buon tutorial da cui partire

* [Tidy TitaRnic
](https://www.kaggle.com/headsortails/tidy-titarnic) fornisce un buon esempio di EDA

* [Titanic using Name only](https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818) fornisce un buon esempio di *feature engineering*

---


```r
# importazione dei dati
PATH &lt;- "https://raw.githubusercontent.com/aldosolari/DM/master/docs/Titanic/"
train &lt;- read.csv(paste0(PATH,"titanic_tr.csv"), 
                  header = TRUE, stringsAsFactors = FALSE)
n &lt;- nrow(train)
test &lt;- read.csv(paste0(PATH,"titanic_te.csv"), 
                 header = TRUE, stringsAsFactors = FALSE)
m &lt;- nrow(test)
# unisco il training set con il test set
combi &lt;- rbind(train, test)
# controllo la tipologia delle variabili
str(combi)
```

```
'data.frame':	1309 obs. of  11 variables:
 $ pclass  : int  3 1 3 1 3 3 1 3 3 2 ...
 $ survived: int  0 1 1 1 0 0 0 0 1 1 ...
 $ name    : chr  "Braund, Mr. Owen Harris" "Cumings, Mrs. John Bradley (Florence Briggs Thayer)" "Heikkinen, Miss. Laina" "Futrelle, Mrs. Jacques Heath (Lily May Peel)" ...
 $ sex     : chr  "male" "female" "female" "female" ...
 $ age     : num  22 38 26 35 35 NA 54 2 27 14 ...
 $ sibsp   : int  1 1 0 1 0 0 0 3 0 1 ...
 $ parch   : int  0 0 0 0 0 0 0 1 2 0 ...
 $ ticket  : chr  "A/5 21171" "PC 17599" "STON/O2. 3101282" "113803" ...
 $ fare    : num  7.25 71.28 7.92 53.1 8.05 ...
 $ cabin   : chr  "" "C85" "" "C123" ...
 $ embarked: chr  "S" "C" "S" "S" ...
```

---

# Tipologia di variabili

| Name | Description |
|---|----|
| pclass   |       Passenger Class (1 = 1st; 2 = 2nd; 3 = 3rd) |
| survived    |   Survival (0 = No; 1 = Yes) |
| name      |      Name |
| sex      |       Sex |
| age      |       Age |
| sibsp     |      Number of Siblings/Spouses Aboard |
| parch     |      Number of Parents/Children Aboard |
| ticket    |      Ticket Number |
| fare      |      Passenger Fare |
| cabin     |      Cabin |
| embarked   |     Port of Embarkation  (C = Cherbourg; Q = Queenstown; S = Southampton) |

Si veda il file [http://biostat.mc.vanderbilt.edu/twiki/pub/Main/DataSets/titanic3info.txt](http://biostat.mc.vanderbilt.edu/twiki/pub/Main/DataSets/titanic3info.txt)

---

# Ricodifica di variabili


```r
# copia della risposta codificata come factor 
combi$survived01 &lt;- combi$survived
combi$survived &lt;- as.factor(combi$survived01)
levels(combi$survived) = c("Death","Alive")

# test survived NA
testsurvived &lt;- combi$survived[(n+1):(n+m)]
combi$survived[(n+1):(n+m)] &lt;- NA
combi$survived01[(n+1):(n+m)] &lt;- NA

# ricodifica di pclass, sex, embarked in factor
combi$pclass &lt;- as.factor(combi$pclass)
combi$sex &lt;- as.factor(combi$sex)
combi$embarked &lt;- as.factor(combi$embarked)

# cabin contiene valori mancanti codificati con "" invece di NA
combi$cabin[combi$cabin==""] &lt;- NA
```

---

layout: false
class: inverse, middle, center

# Valori mancanti

---


```r
library(VIM)
aggr(combi[,-c(2,12)], prop = FALSE, combined = TRUE, numbers = TRUE, sortVars = TRUE, sortCombs = TRUE)
```

![](Titanic_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

```

 Variables sorted by number of missings: 
 Variable Count
    cabin  1014
      age   263
 embarked     2
     fare     1
   pclass     0
     name     0
      sex     0
    sibsp     0
    parch     0
   ticket     0
```


---


```

 Missings in variables:
 Variable Count
      age   263
     fare     1
    cabin  1014
 embarked     2
```

---

# Tariffa (*fare*)


```r
# 1 valore mancante in fare
combi[which(is.na(combi$fare)), ]
```

```
     pclass survived               name  sex  age sibsp parch ticket fare cabin
1282      3     &lt;NA&gt; Storey, Mr. Thomas male 60.5     0     0   3701   NA  &lt;NA&gt;
     embarked survived01
1282        S         NA
```

---

# Sostituzione del valore mancante


```r
aggregate(fare ~ pclass + embarked, combi, FUN=median)
```

```
  pclass embarked    fare
1      1        C 76.7292
2      2        C 15.3146
3      3        C  7.8958
4      1        Q 90.0000
5      2        Q 12.3500
6      3        Q  7.7500
7      1        S 52.0000
8      2        S 15.3750
9      3        S  8.0500
```

```r
combi$fare[which(is.na(combi$fare))] &lt;- 8.0500
```

---

# Porto di imbarcazione (*embarked*)


```r
# 2 valori mancanti in embarked
combi[which(is.na(combi$embarked)), ]
```

```
    pclass survived                                      name    sex age sibsp
62       1    Alive                       Icard, Miss. Amelie female  38     0
830      1    Alive Stone, Mrs. George Nelson (Martha Evelyn) female  62     0
    parch ticket fare cabin embarked survived01
62      0 113572   80   B28     &lt;NA&gt;          1
830     0 113572   80   B28     &lt;NA&gt;          1
```

---

# Biglietto (*ticket*)

![](https://upload.wikimedia.org/wikipedia/commons/a/ad/Ticket_for_the_Titanic%2C_1912.jpg)


---

# Prezzo del biglietto per passeggero


```r
# distribuzione di frequenza del biglietto
combi$ticketFreq &lt;- ave(1:nrow(combi), combi$ticket, FUN=length)

# prezzo del biglietto per passeggero
combi$price &lt;- combi$fare / combi$ticketFreq
```

---


```r
boxplot(price ~ pclass + embarked + sex, data=combi, subset=pclass==1 &amp; sex=="female"); abline(h=40)
```

![](Titanic_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

```r
combi$embarked[which(is.na(combi$embarked))] &lt;- c("C","C")
```

---

# Età (*age*)


```r
# Età come funzione di pclass e sex
aggregate(age ~ pclass + sex, combi, FUN=mean)
```

```
  pclass    sex      age
1      1 female 37.03759
2      2 female 27.49922
3      3 female 22.18533
4      1   male 41.02927
5      2   male 30.81538
6      3   male 25.96226
```

```r
# Modello lineare
fit.age &lt;- lm(age ~ sex*pclass, data = combi[!is.na(combi$age),])

# Sostituzione dei valori mancanti
combi$age[is.na(combi$age)] &lt;- predict(fit.age, newdata=combi[is.na(combi$age),])
```

---

layout: false
class: inverse, middle, center

# Analisi esplorativa

---

# Divisione in training and test 


```r
train &lt;- combi[1:n,]
test &lt;- combi[(n+1):(n+m),]
```

---

# Modello nullo 

* Training set: il 38.38% dei passeggeri è sopravvissuto
* Il modello nullo utilizza solo `\(y\)` e prevede 'nessun sopravvissuto'


```r
round(mean(train$survived01),2)
```

```
[1] 0.38
```

```r
yhat &lt;- rep("Death",m)
# matrice di confusione
table(Predicted=yhat, True=testsurvived)
```

```
         True
Predicted Death Alive
    Death   260   158
```

```r
# accuratezza
mean(yhat == testsurvived)
```

```
[1] 0.6220096
```

---

# Sesso (*sex*)

.pull-left[

Prima le donne?


```r
plot(survived ~ sex, train)
```
]

.pull-right[

![](Titanic_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;
]

---


```r
# modello logistico con solo il sesso
fit &lt;- glm(survived ~ sex, train, family="binomial")
phat &lt;- predict(fit, newdata=test, type = "response")
yhat &lt;- ifelse(phat &gt; 0.5, "Alive","Death")

# matrice di confusione 
table(Predicted=yhat, True=testsurvived)
```

```
         True
Predicted Death Alive
    Alive    46   106
    Death   214    52
```

```r
# accuratezza
mean(yhat == testsurvived)
```

```
[1] 0.7655502
```

Questo modello classifica i passeggeri del test set in funzione del sesso: se donna, sopravvissuta, se uomo, deceduto.

---

# Classe

.pull-left[

I passeggeri che viaggiavano in prima classe hanno avuto maggiore probabilità di sopravvivenza?


```r
plot(survived~pclass, train)
```
]

.pull-right[
![](Titanic_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;
]

---


```r
# modello logistico con solo pclass
fit &lt;- glm(survived ~ pclass, train, family="binomial")
phat &lt;- predict(fit, newdata=test, type = "response")
yhat &lt;- ifelse(phat &gt; 0.5, "Alive","Death")

# matrice di confusione
table(Predicted=yhat, True=testsurvived)
```

```
         True
Predicted Death Alive
    Alive    43    64
    Death   217    94
```

```r
# accuratezza
mean(yhat == testsurvived)
```

```
[1] 0.6722488
```

Questo modello classifica i passeggeri del test set in funzione della classe: se prima, sopravvissuto, se seconda o terza, deceduto.


---

# Età

Prima i bambini? Qual è la relazione tra età e sopravvivenza?


```r
summary(glm(survived ~ age, train, family="binomial"))$coefficients 
```

```
                Estimate Std. Error   z value  Pr(&gt;|z|)
(Intercept) -0.193249397 0.16694357 -1.157573 0.2470383
age         -0.009628612 0.00526435 -1.829022 0.0673963
```

---


.pull-left[
![](Titanic_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;
]



.pull-right[
![](Titanic_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;
]

---

# Età e classe

![](Titanic_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---

# Albero di classificazione

![](Titanic_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;


---

# Regola decisionale

.pull-left[

```r
library(rpart)
library(rpart.plot)
fit &lt;- rpart(survived ~ pclass + age, train, control=rpart.control(maxdepth =  3))
rpart.plot(fit, type=0, extra=2)
```

![](Titanic_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;
]

.pull-right[
| Status | Pr(Death) | Prediction |
|-----------|-----------|------|
| Class 3 |  76% | Death |
| Class 1-2, younger than 18 |  9% | Alive |
| Class 2, older than 18 |  56% | Death |
| Class 1, older than 18 |  39% | Alive | 
]

---



```r
yhat &lt;- predict(fit, newdata=test, type="class")

# matrice di confusione
table(Predicted=yhat, True=testsurvived)
```

```
         True
Predicted Death Alive
    Death   215    86
    Alive    45    72
```

```r
# accuratezza
mean(yhat == testsurvived)
```

```
[1] 0.6866029
```

---

# Modello logistico

| Predictors | Acc.Tr | Acc.Te |
|------------|-------|--------|
| -  |   61.6% |  62.2% |
| age | 61.6% | 62.2% |
| pclass | 67.9% | 67.2% |
| sex | 78.7% | 76.6% |
| age + pclass | 69.1% | 65.3% |
| age + sex | 78.7% | 76.6% |
| pclass + sex | 78.7% | 76.5% |
| age + pclass + sex | 79.5% | 75.6% |

---

# Come migliorare il modello sex-only?

Per migliorare il modello sex-only, dobbiamo capire 

1. quali maschi sopravvivono 

2. quali femmine muoiono

---

# Sesso e età

Molti maschi sopravvissuti sono tra i giovani 

.pull-left[
![](Titanic_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;
]

.pull-right[
![](Titanic_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;
]

---

# Sesso e classe

La maggior parte delle femmine che muoiono viaggiano in terza classe

.pull-left[
![](Titanic_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;
]

.pull-right[
![](Titanic_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;
]

---


```r
# 21/40 maschi sotto i 16 anni sopravvivono
table(train$survived[train$sex=='male' &amp; train$age&lt;16])
```

```

Death Alive 
   19    21 
```

```r
# 72/144 femmine che viaggiano in terza classe non sopravvivono
table(train$survived[train$sex=='female' &amp; train$pclass==3])
```

```

Death Alive 
   72    72 
```


---

layout: false
class: inverse, middle, center

# Feature engineering

---

# Cabina

.pull-left[

```r
# the first character of cabin is the deck
table(substr(combi$cabin, 1, 1))
```

```

 A  B  C  D  E  F  G  T 
22 65 94 46 41 21  5  1 
```
]

.pull-right[
![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Titanic_cutaway_diagram.png/322px-Titanic_cutaway_diagram.png)
]

---

# Titolo


```r
combi$name[1]
```

```
[1] "Braund, Mr. Owen Harris"
```

```r
library(dplyr)
library(stringr)
combi &lt;- combi %&gt;% 
     mutate(title = str_extract(name, "[a-zA-Z]+\\."))
table(combi$title)
```

```

    Capt.      Col. Countess.      Don.     Dona.       Dr. Jonkheer.     Lady. 
        1         4         1         1         1         8         1         1 
   Major.   Master.     Miss.     Mlle.      Mme.       Mr.      Mrs.       Ms. 
        2        61       260         2         1       757       197         2 
     Rev.      Sir. 
        8         1 
```

```r
combi$title &lt;- factor(combi$title)
```

---


```r
plot(survived ~ title, combi[1:n,])
```

![](Titanic_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---

# Uomo, ragazzo o donna?

.pull-left[

```r
combi$wbm &lt;- "man"
combi$wbm[grep('Master',combi$name)] &lt;- "boy"
combi$wbm[combi$sex=="female"] &lt;- "woman"
combi$wbm &lt;- factor(combi$wbm)
plot(survived ~ wbm, combi[1:n,])
```
]

.pull-right[
![](Titanic_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;
]

---

# Distribuzione di frequenza dei cognomi


```r
combi$surname &lt;- substring(combi$name,0,regexpr(",",combi$name)-1)
combi$surnameFreq &lt;- ave(1:nrow(combi),combi$surname,FUN=length)
# famiglie con almeno 5 componenti
table(combi$surname[combi$surnameFreq&gt;4])
```

```

Andersson   Asplund     Brown    Carter    Davies      Ford   Fortune   Goodwin 
       11         8         6         6         7         6         6         8 
  Johnson     Kelly   Lefebre   Palsson    Panula      Rice   Ryerson      Sage 
        6         5         5         5         6         6         5        11 
    Skoog     Smith    Thomas  Williams 
        6         6         5         5 
```

---


```r
train = combi[1:n,]
test = combi[(n+1):(n+m),]
plot(survived ~ as.factor(surname), train[train$surnameFreq==5,])
```

![](Titanic_files/figure-html/unnamed-chunk-37-1.png)&lt;!-- --&gt;


---

# Sopravvivenza di donne e bambini nelle famiglie


```r
combi$surname[combi$wbm=='man'] &lt;- 'noGroup'
combi$surname[combi$surnameFreq&lt;=1] &lt;- 'noGroup'
combi$surnamesurvival &lt;- NA
combi$surnamesurvival[1:n] &lt;- ave(combi$survived01[1:n],combi$surname[1:n])
for (i in (n+1):(n+m)) combi$surnamesurvival[i] &lt;- combi$surnamesurvival[which(combi$surname==combi$surname[i])[1]]
```

---


```r
combi$predict &lt;- "Death"
combi$predict[combi$wbm=='woman'] &lt;- "Alive"
combi$predict[combi$wbm=='boy' &amp; combi$surnamesurvival==1] &lt;- "Alive"
combi$predict[combi$wbm=='woman' &amp; combi$surnamesurvival==0] &lt;- "Death"
combi$predict &lt;- factor(combi$predict)
plot(predict ~ wbm, combi)
```

![](Titanic_files/figure-html/unnamed-chunk-39-1.png)&lt;!-- --&gt;


---
layout: false
class: inverse, middle, center

# Modello Gender Surname

---

![](gendersurname.jpg)

&lt;!-- | Rule | Prediction | --&gt;
&lt;!-- |---|----| --&gt;
&lt;!-- | Man | Death | --&gt;
&lt;!-- | Boy and all females and boys in his family live | Alive | --&gt;
&lt;!-- | Boy and not all females and boys in his family live | Death | --&gt;
&lt;!-- | Female and all females and boys in her family die | Death | --&gt;
&lt;!-- | Female and not all females and boys in her family die | Alive | --&gt;

---


```r
yhat &lt;- combi$predict[1:n]
table(Predicted=yhat, True=train$survived)
```

```
         True
Predicted Death Alive
    Alive    31   253
    Death   518    89
```

```r
mean(yhat == train$survived)
```

```
[1] 0.8653199
```

```r
yhat &lt;- combi$predict[(n+1):(n+m)]
table(Predicted=yhat, True=testsurvived)
```

```
         True
Predicted Death Alive
    Alive    38   113
    Death   222    45
```

```r
mean(yhat == testsurvived)
```

```
[1] 0.8014354
```


---

# Confronto tra modelli

| Model | Acc.Tr | Acc.Te |
|---|----|----|
| All-dead | 61.6% |  62.2% |
| Gender-only | 78.7% | 76.6% |
| Gender surname | 85.5% | 80.1% |
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLanguage": "R",
"countIncrementalSlides": false,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
