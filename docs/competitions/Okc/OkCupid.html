<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>OkCupid</title>
    <meta charset="utf-8" />
    <meta name="author" content="Aldo Solari" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# OkCupid
### Aldo Solari

---




# Outline

* Description
* Data
* Evaluation
* Benchmark
* Timeline


---

# OkCupid

* The original dataset was created with the use of a python script that pulled the data from public profiles on [www.okcupid.com](www.okcupid.com). on 06/30/2012.  Permission to use this data was obtained from OkCupid president and co-founder Christian Rudder under the condition that the dataset remains public

* It has 59946 observations, which includes people within a 25 mile radius of San Francisco, who were online in the last year (06/30/2011), with at least one profile picture

* The goal will be to predict whether a person’s profession is in the __STEM__ fields (science, technology, engineering, and math) using a random sample of the overall dataset


---

# Original data

In their original form, the data set contains several types of variables:
* open text essays related to an individual’s interests and personal descriptions,
* single choice type fields such as profession, diet, gender, body type, and education, and
* multiple choice fields such as languages spoken and fluency in programming languages

See [okcupid_codebook.txt](https://github.com/rudeboybert/JSE_OkCupid/blob/master/okcupid_codebook.txt) and [Kim and Escobedo-Land (2015)](https://github.com/rudeboybert/JSE_OkCupid/blob/master/JSE.pdf) for a description of the original data



---

# Data

* Almost all of raw data fields are discrete in nature; only age was numeric. The categorical predictors and the open text data were converted to dummy variables

* The data set available for the competition is a random sample of the overall dataset

* It contains 90 predictors and 1 response variable (Class, with 2 levels: "other" and "stem")

* The training set has `\(n=4000\)` observations, the test set has `\(m=1000\)` observations

---

# Evaluation

* Submissions are evaluated by the Area Under the Curve (AUC).

* During the competition, the leaderboard displays your partial score, which is the AUC for 500 (random) observations of the test set.
At the end of the contest, the leaderboard will display the final score, which is the AUC for the remaining 500 observations of the test set. The final score will determine the final winner. This method prevents users from overfitting to the leaderboard

---

# Points

The % of __points__ will be calculated as
`$$\frac{x-m}{M-m}$$`
 where
* `\(x\)` is your final score
* `\(M\)` is the best score (among participants)
* `\(m\)` is the benchmark score

However, I reserve the right to regrade differently (meaning your % of points may be calculated differently)

---

# Benchmark


```r
train &lt;- read.csv("101.csv", stringsAsFactors=T)
test &lt;- read.csv("102.csv", , stringsAsFactors=F)
test$Class = NA
n = nrow(train)
m = nrow(test)
combi = rbind(train,test)
train = combi[1:n,]
test = combi[(n+1):(n+m),]

library(rpart)
fit = rpart(Class ~ ., data=train)
phat = predict(fit, newdata=test)[,"stem",drop=F]

write.table(file="myokcupid.txt", phat, row.names = FALSE, col.names = FALSE)
```


---

# Timeline

Entry: October 16

Final submission: November 16

The R code used to get the predictions __must be published online__ by November 17. 
Keep only the necessary code (no plots, numeric summaries etc. )
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLanguage": "R",
"countIncrementalSlides": false,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
